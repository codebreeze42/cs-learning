**题目链接：** [42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked)

# 前后缀分解
依次计算每个宽度为1的柱子所容纳的雨水，可由左右两侧柱子最大高度的最小值减去目前柱子的高度得到，左右两侧柱子的最大高度可分别创建两个数组计算得到。
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        vector<int> pre_max(n);//前缀最大值
        vector<int> suf_max(n);//后缀最大值
        //初始化前缀数组
        pre_max[0]=height[0];
        for(int i=1;i<n;i++){
            pre_max[i]=max(pre_max[i-1],height[i]);
        }
        //初始化后缀数组
        suf_max[n-1]=height[n-1];
        for(int i=n-2;i>=0;i--){
            suf_max[i]=max(suf_max[i+1],height[i]);
        }
        //依次遍历每个柱子计算结果
        int ans=0;
        for(int i=0;i<n;i++){
            ans+=max(0,min(pre_max[i],suf_max[i])-height[i]);
        }
        return ans;
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(n)

# 相向双指针
为降低空间复杂度，相较前后缀分解，使用双指针记录前后缀最大值，先计算前后缀最大值较小的一个，然后指针移动，依次遍历整个数组。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans=0,pre_max=0,suf_max=0,left=0,right=height.size()-1;
        while(left<right){
            pre_max=max(pre_max,height[left]);
            suf_max=max(suf_max,height[right]);
            if(pre_max>suf_max){
                ans+=suf_max-height[right];
                right--;
            }
            else{
                ans+=pre_max-height[left];
                left++;
            }
        }
        return ans;
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(1)