**题目链接：**[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

首先列举一个错误代码
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(root==nullptr) return true;
        if(root->right){
            if(root->right->val<=root->val) return false;
        } 
        if(root->left){
            if(root->left->val>=root->val) return false;
        }
        return isValidBST(root->left)&&isValidBST(root->right);
    }
};
```

反例：
![image.png](https://gitee.com/techstream/mypicture/raw/master/img/20250430084245611.png)
这段代码仅关注于局部，仅考虑根节点的左右结点是否满足二叉搜索树的条件，没有考虑根结点的整个左右子树是否满足二叉搜索树的条件。

**修正：** 抓住二叉搜索树的一个性质：二叉搜索树的中序遍历是升序的。用递归的方法中序遍历二叉搜索树，用pre记录前一个结点，并在中间和当前的根节点比较。

```cpp
class Solution {
public:
    TreeNode* pre=nullptr;
    bool isValidBST(TreeNode* root) {
	    //递归终止的条件
        if(root==nullptr) return true;
        //遍历左子树
        if(!isValidBST(root->left)) return false;
        //判断是否是二叉搜索树
        if(pre!=nullptr&&pre->val>=root->val) return false;
        pre=root;
        //遍历右子树
        return isValidBST(root->right);
    }
};
```
* 时间复杂度：O(n)
* 空间复杂度：O(n)
**关于pre指针的一些思考：** 如果是二叉搜索树，按照中序遍历，pre指针的值会依次增大，满足代码中的判断条件；如果不是则相反。