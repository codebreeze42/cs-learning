**题目链接：**[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)
**解题思路：** 前缀和
**解题过程：** 用两个数组记录每个位置的前缀乘积和后缀乘积，两个相乘即为题目所求
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> suf(nums.size());//记录前缀乘积
        vector<int> pre(nums.size());//记录后缀乘积
        suf[0]=1,pre[nums.size()-1]=1;
        for(int i=1;i<nums.size();i++){
            suf[i]=nums[i-1]*suf[i-1];
        }
        for(int i=nums.size()-2;i>=0;i--){
            pre[i]=nums[i+1]*pre[i+1];
        }
        for(int i=0;i<nums.size();i++){
            nums[i]=suf[i]*pre[i];
        }
        return nums;
    }
};
```
* 时间复杂度：O(n)
* 空间复杂度：O(n)
# 优化：不使用额外空间
据题目要求，输出数组不被视作额外空间，可先将后缀数组初始化为后缀乘积，然后用一个变量在遍历时依次记录前缀乘积
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> pre(nums.size());//后缀乘积
        pre[nums.size()-1]=1;
        for(int i=nums.size()-2;i>=0;i--){
            pre[i]=nums[i+1]*pre[i+1];
        }
        int suf=1;//记录后缀乘积
        for(int i=0;i<nums.size();i++){
            pre[i]=pre[i]*suf;
            suf=suf*nums[i];
        }
        return pre;
    }
};
```
* 时间复杂度：O(n)
* 空间复杂度：O(1)