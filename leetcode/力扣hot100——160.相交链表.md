**题目链接：** [160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)
**解题过程：** 利用链表长度差，先让较长的链表移动若干步，使得两链表剩余部分相同，依次比较剩余部分的结点，遇到第一个相同的结点就返回
```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA=headA,*curB=headB;
        //计算两个链表的长度
        int lenA=1,lenB=1;
        while(curA->next!=NULL){
            curA=curA->next;
            lenA++;
        }
        while(curB->next!=NULL){
            curB=curB->next;
            lenB++;
        }
        //两个链表的最后一个结点都不相同，则不相交
        if(curA!=curB) return NULL;
        //A是较长的一个链表
        if(lenA<lenB) {
            curA=headB;
            curB=headA;
            swap(lenA,lenB);
        }
        else{
            curA=headA;
            curB=headB;
        }
        //使两链表长度相同
        while(lenA!=lenB){
            curA=curA->next;
            lenA--;
        }
        //找第一个相交结点
        while(curA!=curB){
            curA=curA->next;
            curB=curB->next;
        }
        return curA;
    }
};
```

# 优雅解法（参考K神）
**思路:** 遍历自身结点，遍历完后再遍历另一条链表。如果两链表相交，则此时结点相同。如果不相交，此时两结点均为空。
```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* A=headA,*B=headB;
        while(A!=B){
            A=(A!=NULL)?A->next:headB;
            B=(B!=NULL)?B->next:headA;
        }
        return A;
    }
};
```

* 时间复杂度：O(m+n)
* 空间复杂度：O(1)