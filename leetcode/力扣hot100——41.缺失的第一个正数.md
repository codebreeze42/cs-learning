**题目链接：** [41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/?envType=study-plan-v2&envId=top-100-liked)
**解题思路：** 将数组看作哈希表以节省空间
**解题过程：** 数组的映射规则是第i个位置存放值为i+1的元素，首先按照数组映射规则交换数组，然后依次遍历数组找到第一个不符合数组映射规则的元素，如果没有找到则为数组长度加1
```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        for(int i=0;i<=nums.size();i++){
            while(nums[i]>0&&nums[i]//不在正数范围内的不考虑<nums.size()&&nums[i]!=nums[nums[i]-1]){ //防止遇到重复元素进入死循环
                swap(nums[i],nums[nums[i]-1]); 
            }
        }
        for(int i=0;i<nums.size();i++){
            if(nums[i]!=i+1) return i+1;
        }
        return nums.size()+1;
    }
};
```
* 时间复杂度：O(n)
* 空间复杂度：O(1)
## 一些思考
为什么是nums\[i]!=nums\[nums\[i]-1] 而不是nums\[i]!=i+1
原因是防止死循环，\[1,1]就是反例
nums\[i]!=nums\[nums\[i]-1]的逻辑是如果nums\[nums\[i]-1]这个位置上的元素不是正确元素，那么就把nums\[i]放在这个位置上；而nums\[i]!=i+1没有考虑nums\[nums\[i]-1]这个位置上的元素是否已经符合要求。两者本质都是把当前遍历元素放到正确位置，前者考虑了重复的可能，如果不重复才放；而后者没有考虑，最终导致死循环