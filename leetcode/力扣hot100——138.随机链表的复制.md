**题目链接：**[138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

# 哈希表
利用哈希表，构造原链表结点与新链表结点的映射关系。然后利用哈希表，构建新链表结点的指向（next和random）
```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==NULL) return NULL;
        unordered_map<Node*,Node*> map;//第一个是原结点，第二个是新结点
        Node* cur=head;
        //构建哈希表
        while(cur){
            map[cur]=new Node(cur->val);
            cur=cur->next;
        }
        //构建指向
        cur=head;
        while(cur){
            map[cur]->next=map[cur->next];
            map[cur]->random=map[cur->random];
            cur=cur->next;
        }
        return map[head];
    }
};
```
* 时间复杂度：O(n) 遍历两次链表
* 空间复杂度：O(n) 使用哈希表存储链表结点

# 拼接加拆分
第一次遍历：在原链表的基础上，在每一个结点后面复制一个与它相同的结点
第二次遍历：构建新结点的random指向
第三次遍历：将新结点和旧结点拆分为两个链表，返回新链表
```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==NULL) return NULL;
        Node* cur=head;
        //复制链表
        while(cur){
            Node* temp=new Node(cur->val);
            temp->next=cur->next;
            cur->next=temp;
            cur=cur->next->next;
        }
        //复制random
        cur=head;
        while(cur){
	        //考虑random为空的情况
            if(cur->random!=NULL)
            cur->next->random=cur->random->next;
            cur=cur->next->next;
        }
        //将两链表拆开
        cur=head;
        Node* res=cur->next;
        Node* cur1=res;
        while(cur1->next){
            cur->next=cur->next->next;
            cur1->next=cur1->next->next;
            cur=cur->next;
            cur1=cur1->next;
        }
        cur->next=NULL; //单独处理原链表尾节点
        return res;
    }
};
```

* 时间复杂度：O(n) 遍历三次链表
* 空间复杂度：O(1) 不使用额外变量
