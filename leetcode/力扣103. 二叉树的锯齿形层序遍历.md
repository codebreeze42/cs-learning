**题目链接：**[103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)
**解题思路：** 此题是层序遍历的加强版，在此基础上实现遍历顺序交替变换即可。
# 方法一：双向队列
双向队列首尾均可添加元素，如果向尾部添加即可实现正序，向首部添加即可实现倒序
```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res=new ArrayList<>();
        if(root==null) return res;
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        boolean reverse=false;//据此判断是否需要反转
        while(!queue.isEmpty()){
            LinkedList<Integer> path=new LinkedList<>();
            int length=queue.size();
            for(int i=0;i<length;i++){
                TreeNode cur=queue.poll();
                if(reverse) path.addFirst(cur.val);//倒序
                else path.addLast(cur.val);//正序
                if(cur.left!=null) queue.add(cur.left);
                if(cur.right!=null) queue.add(cur.right);
            }
            res.add(path);
            reverse=!reverse;
        }
        return res;
    }
}
```
* 时间复杂度：O($n$) 需要遍历整颗二叉树
* 空间复杂度：O($n$) 如果是满二叉树，遍历最后一层时会有n/2个结点在队列中
# 方法二：使用reverse函数实现倒序
```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res=new ArrayList<>();
        if(root==null) return res;
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            List<Integer> path=new ArrayList<>();
            int length=queue.size();
            for(int i=0;i<length;i++){
                TreeNode cur=queue.poll();
                path.add(cur.val);
                if(cur.left!=null) queue.add(cur.left);
                if(cur.right!=null) queue.add(cur.right);
            }
            if(res.size()%2==1) Collections.reverse(path); //根据层数判断是否需要倒序
            res.add(path);
        }
        return res;
    }
}
```
* 时间复杂度：O($n$) 需要遍历整颗二叉树
* 空间复杂度：O($n$) 如果是满二叉树，遍历最后一层时会有n/2个结点在队列中

**补充：**
为什么最多有N/2个节点在队列中
- 一棵高度为h的满二叉树，总节点数N = 2ʰ - 1
- 最底层（第h层）的节点数 = 2ʰ⁻¹
- 所以最底层节点数 = (N + 1)/2 ≈ N/2