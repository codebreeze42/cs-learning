**题目链接：**[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked)
我自己的解法：由于没有设立虚拟头结点，而是定义了一个pre指针，导致略显冗余，额外定义了翻转后的头结点，循环条件无法利用，而是在循环中添加循环条件
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* p1=head,*p2=head->next,*pre=nullptr;
        ListNode* head1=p2;//翻转后的头结点
        while(true){
	        //交换
            ListNode* temp=p2->next;
            p1->next=p2->next;
            p2->next=p1;
            if(pre!=nullptr) pre->next=p2;
            pre=p1;
            //判断下一次迭代是否合法
            if(temp==nullptr||temp->next==nullptr) break;
            //迭代
            p1=temp;
            p2=temp->next;
        }
        return head1;
    }
};
```

# 引入虚拟头结点

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* head1=new ListNode();//虚拟头结点
        head1->next=head;
        ListNode* temp=head1;//temp相当于上一个题解的pre，可以连接交换后的结点
        while(temp->next!=nullptr&&temp->next->next!=nullptr){
            //更新start和end
            ListNode* start=temp->next;
            ListNode* end=temp->next->next;
            //交换
            start->next=end->next;
            end->next=start;
            temp->next=end;
            //更新
            temp=start;
        }
        return head1->next;
    }
};
```

# 递归
个人总结的写递归的一些方法：将问题分解为子问题，专注子问题的过程，不要过分研究递归的过程，将递归看作一个整体，利用递归返回的结果即可。其次确定好递归终止条件，使得递归能够停止。
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
	    //终止条件
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* next=head->next;
        head->next=swapPairs(next->next);
        next->next=head;
        return next;
    }
};
```